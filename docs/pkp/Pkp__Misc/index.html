<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pkp__Misc (pkp.Pkp__Misc)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">pkp</a> &#x00BB; Pkp__Misc</nav><h1>Module <code>Pkp__Misc</code></h1><p>Miscellaneous functions</p><nav class="toc"><ul><li><a href="#library-upgrade">Library upgrade</a></li><li><a href="#interacting-with-the-notebook">Interacting with the notebook</a></li><li><a href="#signals">Signals</a></li><li><a href="#memoization">Memoization</a></li><li><a href="#histograms">Histograms</a></li></ul></nav></header><section><header><h2 id="library-upgrade"><a href="#library-upgrade" class="anchor"></a>Library upgrade</h2></header><dl><dt class="spec value" id="val-upgrade"><a href="#val-upgrade" class="anchor"></a><code><span class="keyword">val</span> upgrade : unit <span>&#45;&gt;</span> <span><span>(unit, <span>[&gt; Rresult.R.msg ]</span>)</span> Bos.OS.result</span></code></dt><dd><p>Run this command within your Jupyter notebook to update to the latest version of the Pkp library. Do not forget to restart your kernel afterwards, and run <code>#require &quot;pkp&quot;</code> again.</p></dd></dl></section><section><header><h2 id="interacting-with-the-notebook"><a href="#interacting-with-the-notebook" class="anchor"></a>Interacting with the notebook</h2></header><dl><dt class="spec value" id="val-quiet_owl"><a href="#val-quiet_owl" class="anchor"></a><code><span class="keyword">val</span> quiet_owl : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Stop printing the content of Owl matrices in the notebook.</p></dd></dl><dl><dt class="spec value" id="val-hooting_owl"><a href="#val-hooting_owl" class="anchor"></a><code><span class="keyword">val</span> hooting_owl : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Resume printing the content of Owl matrices in the notebook.</p></dd></dl><dl><dt class="spec type" id="type-placeholder"><a href="#type-placeholder" class="anchor"></a><code><span class="keyword">type</span> placeholder</code></dt></dl><dl><dt class="spec value" id="val-placeholder"><a href="#val-placeholder" class="anchor"></a><code><span class="keyword">val</span> placeholder : unit <span>&#45;&gt;</span> <a href="index.html#type-placeholder">placeholder</a></code></dt><dd><p>Returns a placeholder for output messages to be displayed in the notebook. Many functions below accept such placeholders as optional arguments.</p></dd></dl><dl><dt class="spec value" id="val-print_msg"><a href="#val-print_msg" class="anchor"></a><code><span class="keyword">val</span> print_msg : <span>?&#8288;ph:<a href="index.html#type-placeholder">placeholder</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Prints a message (optionally in a placeholder you specify, otherwise in a new placeholder)</p></dd></dl><dl><dt class="spec value" id="val-with_indicator"><a href="#val-with_indicator" class="anchor"></a><code><span class="keyword">val</span> with_indicator : <span>?&#8288;ph:<a href="index.html#type-placeholder">placeholder</a></span> <span>&#45;&gt;</span> <span>?&#8288;description:string</span> <span>&#45;&gt;</span> <span>(<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span></code></dt><dd><p>Take an iter / map function (such as <code>Array.{map/iter}, List.{map/iter}, Mat.{map/iter}, ...</code>), and make a new one that does the same thing but also indicates progress in the notebook. For example:</p><pre><code class="ml">let a = Mat.linspace 0. 1. 10
let ph = placeholder ()
let _ = (with_indicator Mat.iter)
  (fun x -&gt; print_msg ~ph (string_of_float x); Unix.sleepf 0.2)
  a</code></pre></dd></dl><dl><dt class="spec value" id="val-average_over"><a href="#val-average_over" class="anchor"></a><code><span class="keyword">val</span> average_over : <span>?&#8288;display:<span>(<a href="index.html#type-placeholder">placeholder</a> * string)</span></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> float)</span> <span>&#45;&gt;</span> float * <span>(float * float)</span></code></dt><dd><p><code>average_over n f</code> return <code>mu, (lb, ub)</code> where <code>mu</code> is the average of <code>f ()</code> over <code>n</code> trials, and <code>(lb, ub)</code> are the lower and upper bound of the 95% confidence interval.</p><p>If <code>f</code> takes a long time to evaluate (e.g. because it involves a lot of computational work), you might want to use the optional <code>display</code> argument to monitor progress in the notebook. This optional argument should be a pair of the form <code>(placeholder, string_description)</code> (try it!). For example:</p><pre><code class="ml">let ph = placeholder ()
let result = average_over ~display:(ph, &quot;i&quot;) 100 (fun () -&gt; Unix.sleepf 0.2; Random.float 1.)</code></pre><p>will return the average of random numbers between 0. and 1. (which is 0.5), along with the 95% confidence interval. It will display progress along the way in the notebook (here I intentionally slow down the computation by using <code>Unix.sleepf 0.2</code> to force OCaml to wait 200ms each time).</p></dd></dl><dl><dt class="spec value" id="val-how_long"><a href="#val-how_long" class="anchor"></a><code><span class="keyword">val</span> how_long : <span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * float</code></dt><dd><p><code>how_long f</code> returns the evaluation <code>f ()</code> along with the time (in s) it took to do this.</p></dd></dl></section><section><header><h2 id="signals"><a href="#signals" class="anchor"></a>Signals</h2></header><dl><dt class="spec value" id="val-ou_process"><a href="#val-ou_process" class="anchor"></a><code><span class="keyword">val</span> ou_process : <span>tau:float</span> <span>&#45;&gt;</span> <span>dt:float</span> <span>&#45;&gt;</span> <span>duration:float</span> <span>&#45;&gt;</span> Owl.Mat.mat</code></dt><dd><p>Generates a unit-variance Ornstein-Uhlenbeck process with characteristic time constant <code>tau</code>, over a <code>duration</code> with sampling resolution <code>dt</code>.</p></dd></dl></section><section><header><h2 id="memoization"><a href="#memoization" class="anchor"></a>Memoization</h2></header><dl><dt class="spec value" id="val-memoize"><a href="#val-memoize" class="anchor"></a><code><span class="keyword">val</span> memoize : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-memoize_rec"><a href="#val-memoize_rec" class="anchor"></a><code><span class="keyword">val</span> memoize_rec : <span>(<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt></dl></section><section><header><h2 id="histograms"><a href="#histograms" class="anchor"></a>Histograms</h2></header><dl><dt class="spec value" id="val-hist"><a href="#val-hist" class="anchor"></a><code><span class="keyword">val</span> hist : <span>n_bins:int</span> <span>&#45;&gt;</span> Owl.Mat.mat <span>&#45;&gt;</span> Owl.Mat.mat</code></dt><dd><p>Computes a histogram given a matrix of numbers. Returns a matrix with two columns, where the first column are the bins (x-axis) and the second column are the counts (number of elements in the input matrix that fall within the corresponding bin). You may plot the result using:</p><pre><code class="ml">P.plot (A your_histogram) ~style:&quot;boxes fs solid 0.5 lc 8&quot; default_props</code></pre></dd></dl></section></div></body></html>